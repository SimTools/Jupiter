DXYZ_MARGIN = G4ThreeVector(0.01*cm,0.01*cm,0.01*cm);
R_MARGIN = 0.05*cm;
G4double R_MARGIN_PLUS = 0.01*cm;
//G4double Tolerance = 1E-9*mm;	
G4double Tolerance = 0.0*mm;
DXYZ_SENSOR = G4ThreeVector(1.25*cm,330e-4*cm,5.0*cm);
DXYZ_SENSOR_GAP = G4ThreeVector(0.*cm,0.*cm,0.*cm);

DXYZ_SUBSTRATE = G4ThreeVector(DXYZ_SENSOR.x()-Tolerance,
				300e-3*mm-Tolerance,
				DXYZ_SENSOR.z()-Tolerance);
DXYZ_EPITAXIAL = G4ThreeVector(DXYZ_SENSOR.x()-Tolerance,
				30e-3*mm-Tolerance,
				DXYZ_SENSOR.z()-Tolerance);

XYZ_SUBSTRATE  = G4ThreeVector(0.*cm,-DXYZ_EPITAXIAL.y()/2.,0.*cm);
XYZ_EPITAXIAL  = G4ThreeVector(0.*cm,+DXYZ_SUBSTRATE.y()/2.,0.*cm);

DXYZ_PIXELAREA = 
   G4ThreeVector(DXYZ_EPITAXIAL.x()-Tolerance,
		 DXYZ_EPITAXIAL.y()-Tolerance,
		 DXYZ_SENSOR.z()-Tolerance);
XYZ_PIXELAREA  = G4ThreeVector(0.*cm,0.,0.*cm);

NLAYER = 4;
NLADDER = new G4int[NLAYER];
NLADDER[0]=16;
NLADDER[1]=24;
NLADDER[2]=32;
NLADDER[3]=40;
NSENSOR = new G4int[NLAYER];
NSENSOR[0]=2;
NSENSOR[1]=3;
NSENSOR[2]=4;
NSENSOR[3]=5;

TILT_LADDER = new G4double[NLAYER];
TILT_LADDER[0]=10.*deg;
TILT_LADDER[1]=10.*deg;
TILT_LADDER[2]=10.*deg;
TILT_LADDER[3]=10.*deg;
R_LAYER = new G4double[NLAYER];
R_LAYER[0]=2.4*cm;
R_LAYER[1]=3.6*cm;
R_LAYER[2]=4.8*cm;
R_LAYER[3]=6.0*cm;

XYZ_LAYER = G4ThreeVector(0.*cm,0.*cm,0.*cm);
DXYZ_LADDER = new G4ThreeVector* [NLAYER];
DR_LAYER = new G4double[NLAYER];
RINNER_LAYER = new G4double[NLAYER];
ROUTER_LAYER = new G4double[NLAYER];
VTXMASTER_PHI=360.*deg;

for( G4int layer = 0; layer<NLAYER; layer++){

  DXYZ_LADDER[layer] = new G4ThreeVector();
  DXYZ_LADDER[layer]->setX(DXYZ_SENSOR.x()+2.*DXYZ_MARGIN.x());
  DXYZ_LADDER[layer]->setY(DXYZ_SENSOR.y()+DXYZ_SUBSTRATE.y()/2.
					  +2.*DXYZ_MARGIN.y());
  DXYZ_LADDER[layer]->setZ(
	NSENSOR[layer]*DXYZ_SENSOR.z()
	+2.*DXYZ_MARGIN.z()+(NSENSOR[layer]-1)*DXYZ_SENSOR_GAP.z());

  G4double theta = 360.*deg/NLADDER[layer];
  for (G4int ladder=0; ladder<NLADDER[layer]; ladder++){
	  XYZ_LADDER[layer][ladder].setX(R_LAYER[layer]*cos(ladder*theta));
	  XYZ_LADDER[layer][ladder].setY(R_LAYER[layer]*sin(ladder*theta));
	  XYZ_LADDER[layer][ladder].setZ(0.*cm);
	  ANGLE_LADDER[layer][ladder] = 
		-90.*deg-theta*ladder + TILT_LADDER[layer];
  }

  RINNER_LAYER[layer] = sqrt(
		    pow(R_LAYER[layer]*cos(TILT_LADDER[layer]),2.)
		   +pow(
			max(0.,
	 R_LAYER[layer]*sin(TILT_LADDER[layer])-DXYZ_LADDER[layer]->x()/2.),2.)
	           )-DXYZ_LADDER[layer]->y()/2/cos(TILT_LADDER[layer])
	 -R_MARGIN;
  ROUTER_LAYER[layer] = sqrt(
		    pow(R_LAYER[layer]*cos(TILT_LADDER[layer]),2.)
		   +pow(R_LAYER[layer]*sin(TILT_LADDER[layer])
		   +DXYZ_LADDER[layer]->x()/2.,2.)
		   )+DXYZ_LADDER[layer]->y()/2/cos(TILT_LADDER[layer])
	 +R_MARGIN+R_MARGIN_PLUS;

  for ( G4int sensor=0; sensor < NSENSOR[layer] ; sensor++){
	XYZ_SENSOR[layer][sensor] = G4ThreeVector();
	XYZ_SENSOR[layer][sensor].setX(0.*cm);
	XYZ_SENSOR[layer][sensor].setY(-DXYZ_SUBSTRATE.y()/2.);
	XYZ_SENSOR[layer][sensor].setZ(
 	  (DXYZ_SENSOR_GAP.z()+DXYZ_SENSOR.z())
	 *((G4double)(sensor+1)-(G4double)(NSENSOR[layer]+1)/2.)
	);
  } 
}


VTXMASTER_INNER_R = RINNER_LAYER[0]-R_MARGIN;
VTXMASTER_OUTER_R = ROUTER_LAYER[NLAYER-1]+R_MARGIN;
VTXMASTER_Z = DXYZ_LADDER[NLAYER-1]->z()+2.*DXYZ_MARGIN.z();

ZPIXELSIZE = 25e-3*mm; 
XPIXELSIZE = 25e-3*mm; 
NZPIXEL  = 2000;
NXPIXEL  = 500;
